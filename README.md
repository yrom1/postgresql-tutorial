# Basic PostgreSQL Tutorial

```sql
-- order of operations:
/*
FROM
WHERE
GROUP BY
HAVING
SELECT
DISTINCT
ORDER BY
LIMIT
*/
```

## Section 1. Querying Data

### Select – show you how to query data from a single table.

```sql
SELECT
   first_name,
   last_name,
   email
FROM
   customer;
SELECT * FROM customer;
SELECT
   first_name || ' ' || last_name,
   email
FROM
   customer;
SELECT 5 * 3; -- expression
```

### Column aliases – learn how to assign temporary names to columns or expressions in a query.

```sql
SELECT
   first_name,
   last_name AS surname
FROM customer;
column_name AS "column alias"
SELECT
    first_name || ' ' || last_name "full name"
FROM
    customer;
```

### Order By – guide you on how to sort the result set returned from a query.

```sql
SELECT
	select_list
FROM
	table_name
ORDER BY
	sort_expression1 [ASC | DESC],
        ...
	sort_expressionN [ASC | DESC];
-- default is ASC
SELECT
	first_name,
	LENGTH(first_name) len
FROM
	customer
ORDER BY
	len DESC;
-- When you sort rows that contains NULL, you can specify the order
-- of NULL with other non-null values by using the NULLS FIRST or
-- NULLS LAST option of the ORDER BY clause:
-- ORDER BY sort_expresssion [ASC | DESC] [NULLS FIRST | NULLS LAST]
SELECT num
FROM sort_demo
ORDER BY num DESC NULLS LAST;
```

### Select Distinct – provide you a clause that removes duplicate rows in the result set.

```sql
SELECT
   DISTINCT column1
FROM
   table_name;
SELECT
	DISTINCT bcolor,
	fcolor
FROM
	distinct_demo
ORDER BY
	bcolor,
	fcolor;
-- Because we specified both bcolor and fcolor columns in the
-- SELECT DISTINCT clause, PostgreSQL combined the values in both
-- bcolor and fcolor columns to evaluate the uniqueness of the rows.
SELECT
	DISTINCT ON (bcolor) bcolor,
	fcolor
FROM
	distinct_demo
ORDER BY
	bcolor,
	fcolor;
-- PostgreSQL also provides the DISTINCT ON (expression) to keep the
-- “first” row of each group of duplicates using the following syntax:
```

## Section 2. Filtering Data

### Where – filter rows based on a specified condition.

```
Operator	Description
=	Equal
>	Greater than
<	Less than
>=	Greater than or equal
<=	Less than or equal
<> or !=	Not equal
AND	Logical operator AND
OR	Logical operator OR
IN	Return true if a value matches any value in a list
BETWEEN	Return true if a value is between a range of values
LIKE	Return true if a value matches a pattern
IS NULL	Return true if a value is NULL
NOT	Negate the result of other operators
```

```sql
SELECT select_list
FROM table_name
WHERE condition
ORDER BY sort_expression;
SELECT
	first_name,
	last_name
FROM
	customer
WHERE
	last_name = 'Rodriguez' OR
	first_name = 'Adam';
SELECT
	first_name,
	last_name
FROM
	customer
WHERE
	first_name IN ('Ann','Anne','Annie');
SELECT
	first_name,
	LENGTH(first_name) name_length
FROM
	customer
WHERE
	first_name LIKE 'A%' AND
	LENGTH(first_name) BETWEEN 3 AND 5
ORDER BY
	name_length;
```

### Limit – get a subset of rows generated by a query.

```sql
SELECT select_list
FROM table_name
LIMIT row_count OFFSET row_to_skip;
```

### Fetch– limit the number of rows returned by a query.

```sql
SELECT
    film_id,
    title
FROM
    film
ORDER BY
    title
OFFSET 5 ROWS
FETCH FIRST 5 ROW ONLY;
-- The LIMIT clause is not a SQL-standard. To conform with the
-- SQL standard, PostgreSQL supports the FETCH clause
```

### In – select data that matches any value in a list of values.

```sql
-- value IN (value1,value2,...)
value IN (SELECT column_name FROM table_name);
SELECT
	customer_id,
	first_name,
	last_name
FROM
	customer
WHERE
	customer_id IN (
		SELECT customer_id
		FROM rental
		WHERE CAST (return_date AS DATE) = '2005-05-27'
	)
ORDER BY customer_id;
```

### Between – select data that is a range of values.

```sql
-- value BETWEEN low AND high;
-- (value >= low AND value <= high;)
SELECT
	amount
FROM
	payment
WHERE
	amount NOT BETWEEN 8 AND 9;
SELECT
   payment_date
FROM
	payment
WHERE
	payment_date BETWEEN '2007-02-07' AND '2007-02-15';
```

### Like – filter data based on pattern matching.

```sql
SELECT
	'foo' LIKE 'foo', -- true
	'foo' LIKE 'f%', -- true
	'foo' LIKE '_o_', -- true
	'bar' LIKE 'b_'; -- false
```

```
Operator	Equivalent
~~	LIKE
~~*	ILIKE
!~~	NOT LIKE
!~~*	NOT ILIKE
```

```sql
select 'abc' LIKE 'a__';
-- is equal to:
select 'abc' ~~ 'a__';
```

### Is Null – check if a value is null or not.

```sql
-- select NULL = NULL; -> NULL
-- value IS NULL
SELECT
    phone
FROM
    contacts
WHERE
    phone IS /* NOT */ NULL;
```

## Section 3. Joining Multiple Tables

### Joins – show you a brief overview of joins in PostgreSQL.

```sql
-- inner join
SELECT
    a,
    fruit_a,
    b,
    fruit_b
FROM
    basket_a
INNER JOIN basket_b
    ON fruit_a = fruit_b;

-- left outer join
SELECT
    a,
    fruit_a,
    b,
    fruit_b
FROM
    basket_a
LEFT JOIN basket_b
   ON fruit_a = fruit_b;

-- left outer join, only left rows
SELECT
    a,
    fruit_a,
    b,
    fruit_b
FROM
    basket_a
LEFT JOIN basket_b
    ON fruit_a = fruit_b
WHERE b IS NULL;

-- right outer join
SELECT
    a,
    fruit_a,
    b,
    fruit_b
FROM
    basket_a
RIGHT JOIN basket_b ON fruit_a = fruit_b;

-- right outer join, only right rows
SELECT
    a,
    fruit_a,
    b,
    fruit_b
FROM
    basket_a
RIGHT JOIN basket_b
   ON fruit_a = fruit_b
WHERE a IS NULL;

-- full outer join
SELECT
    a,
    fruit_a,
    b,
    fruit_b
FROM
    basket_a
FULL OUTER JOIN basket_b
    ON fruit_a = fruit_b;

-- full outer join, only unique to both tables
SELECT
    a,
    fruit_a,
    b,
    fruit_b
FROM
    basket_a
FULL JOIN basket_b
   ON fruit_a = fruit_b
WHERE a IS NULL OR b IS NULL;
```

### Table aliases – describes how to use table aliases in the query.

```sql
-- a_very_long_table_name.column_name
-- a_very_long_table_name AS alias
-- alias.column_name
SELECT
    e.first_name employee,
    m .first_name manager
FROM
    employee e
INNER JOIN employee m
    ON m.employee_id = e.manager_id
ORDER BY manager;
```

### Self-join – join a table to itself by comparing a table to itself.

```sql
SELECT select_list
FROM table_name t1
INNER JOIN table_name t2 ON join_predicate;
SELECT select_list
FROM table_name t1
LEFT JOIN table_name t2 ON join_predicate;
```

### Cross Join – produce a Cartesian product of the rows in two or more tables.

```sql
SELECT select_list
FROM T1
CROSS JOIN T2;
SELECT select_list
FROM T1, T2;
-- Also, you can use an INNER JOIN clause with a condition that always
-- evaluates to true to simulate the cross join:

SELECT *
FROM T1
INNER JOIN T2 ON true;
```

### Natural Join – join two or more tables using implicit join condition based on the common column names in the joined tables.

```sql
-- A natural join is a join that creates an implicit join based
-- on the same column names in the joined tables.
SELECT	* FROM products
INNER JOIN categories USING (category_id); -- brackets NECESSARY
-- becomes:
SELECT * FROM products
NATURAL JOIN categories;
```

## Section 4. Grouping Data

### Group By – divide rows into groups and applies an aggregate function on each.

```sql
SELECT
   customer_id
FROM
   payment
GROUP BY
   customer_id;
-- In this case, the GROUP BY works like the DISTINCT clause
-- that removes duplicate rows from the result set.

SELECT
	customer_id,
	SUM (amount)
FROM
	payment
GROUP BY
	customer_id;
SELECT
	DATE(payment_date) paid_date,
	SUM(amount) sum
FROM
	payment
GROUP BY
	DATE(payment_date);
```

### Having – apply conditions to groups.

```sql
SELECT
	store_id,
	COUNT (customer_id)
FROM
	customer
GROUP BY
	store_id
HAVING
	COUNT (customer_id) > 300;
```

## Section 5. Set Operations

### Union – combine result sets of multiple queries into a single result set.

```sql
SELECT * FROM top_rated_films
UNION
SELECT * FROM most_popular_films;
SELECT * FROM top_rated_films
UNION ALL
SELECT * FROM most_popular_films;
```

### Intersect – combine the result sets of two or more queries and returns a single result set that has the rows appear in both result sets.

```sql
SELECT * FROM most_popular_films
INTERSECT
SELECT * FROM top_rated_films;
```

### Except – return the rows in the first query that does not appear in the output of the second query.

```sql
SELECT * FROM top_rated_films
EXCEPT
SELECT * FROM most_popular_films;
```
